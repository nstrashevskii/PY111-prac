import networkx as nx

# посчитать самый дешевый путь, и вернуть то как мы шли(алгоритм дейкстры посмотреть в библиотеке nx)

# all_way = [[2, 7, 9, 3],
#            [12, 4, 1, 9],
#            [1, 5, 2, 5]]
#
#
# def min_way():
#     ...


#  2. поиск в глубину(ищем компонент связанности) посмотреть что такое компонент связанности


def count_connected(G: nx.Graph) -> int:
    nx.bfs_tree()  # поиск в ширину
    nx.dfs_tree()  # поиск в глубину


if __name__ == '__main__':
    g = nx.DiGraph()
    g.add_nodes_from("ABCDEFG")  # инициализация вершин
    g.add_edges_from([('A', 'B'), ('B', 'C'), ('C', 'D'), ('F', 'G')])
    print(g.adj)
    for node, edges in g.adj.items():
        print(node, edges)

    count = count_connected(g)
    assert count == 3


# 3. Вы – компания, дающая в аренду ракеты.
# Каждый день к вам приходит список заявок на использование ракет в виде: (час_начала, час_конца),
# (час_начала, час_конца), ...
# Если аренда ракеты заканчивается в час X,
# то в этот же час ее уже можно взять в аренду снова
# (т.е. час_начала может начинаться с Х).

# Дано: список заявок на использование ракет
# Задача: вывести ответ, хватит ли вам одной ракеты,
# чтобы удовлетворить все заявки на этот день

# решение через граф
# граф мульти-направленный(больше чем одна связь), не можем удовлетворить заявку когда колличество
# исходящих связей из одной вершины больше чем одна(исходящая степень(degree) вершины больше 1)
g1 = nx.MultiDiGraph()

